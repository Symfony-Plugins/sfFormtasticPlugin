<?php

/**
 * @todo Sister validators in field class, including copy of options...
 * @todo Pre and post validators in field class
 */

/**
 * Generates sfFormtastic YAML forms.
 * 
 * @package     sfFormtasticPlugin
 * @subpackage  generator
 * @author      Kris Wallsmith
 * @version     SVN: $Id$
 */
class sfFormtasticYamlGenerator extends sfGenerator
{
  /**
   * Creates an instance of the supplied widget or validator class.
   * 
   * @param   string $class
   * 
   * @return  mixed
   * 
   * @throws  InvalidArgumentException If the class is not a widget or validator
   */
  static public function createInstanceOf($class)
  {
    $rc = new ReflectionClass($class);
    if (!$rc->isSubclassOf(new ReflectionClass('sfWidget')) && !$rc->isSubclassOf('sfValidatorBase'))
    {
      throw new InvalidArgumentException('The supplied class "%s" is neither a widget nor validator.', $class);
    }
    
    try
    {
      $object = new $class;
    }
    catch (RuntimeException $e)
    {
      preg_match_all('/\'(\w+)\'/', $e->getMessage(), $matches);
      
      $options = array();
      foreach ($matches[1] as $match)
      {
        $options[$match] = null;
      }
      
      $object = new $class($options);
    }
    
    return $object;
  }
  
  /**
   * @see sfGenerator
   */
  public function initialize(sfGeneratorManager $generatorManager)
  {
    parent::initialize($generatorManager);
    
    $this->setGeneratorClass('sfFormtasticYaml');
  }
  
  /**
   * @see sfGenerator
   */
  public function generate($params = array())
  {
    $data = <<<EOF
<?php

/*
 * auto-generated by sfFormtasticYamlGenerator
 * date: %s
 */


EOF;
    $data = sprintf($data, date('Y/m/d H:i:s'));
    
    foreach ($params as $formClass => $formParams)
    {
      $this->form = new sfFormtasticYamlForm($formClass, $formParams);
      
      $data .= $this->evalTemplate('sfFormtasticYamlTemplate.php');
    }
    
    return $data;
  }
  
  /**
   * Export a variable and cleanup its presentation.
   * 
   * @param   mixed $var
   * 
   * @return  string
   */
  public function var_export($var)
  {
    $export = var_export($var, true);
    
    if (0 === strpos($export, 'array ('))
    {
      $export = preg_replace('/\s+/', ' ', $export);
      $export = str_replace(array(' ( ', ', )'), array('(', ')'), $export);
      if (false === strpos('\' => ', $export))
      {
        $export = preg_replace('/\d+ => /', '', $export);
      }
    }
    
    return $export;
  }
}

/**
 * YAML form.
 * 
 * @package     sfFormtasticPlugin
 * @subpackage  generator
 * @author      Kris Wallsmith
 * @version     SVN: $Id$
 */
class sfFormtasticYamlForm
{
  protected
    $class              = null,
    $nameFormat         = null,
    $fields             = array(),
    $preValidators      = array(),
    $postValidators     = array(),
    $maxFieldNameLength = 0;
  
  /**
   * Constructor.
   * 
   * @param   string  $className
   * @param   array   $params
   */
  public function __construct($class, $params = array())
  {
    $this->initialize($class, $params);
  }
  
  /**
   * Initializes this form.
   * 
   * @param   string  $className
   * @param   array   $params
   */
  public function initialize($class, $params = array())
  {
    $this->class = $class;
    
    if (isset($params['name_format']))
    {
      $this->nameFormat = $params['name_format'];
    }
    
    foreach ($params['fields'] as $fieldName => $fieldParams)
    {
      $field = new sfFormtasticYamlField($fieldName, $fieldParams);
      
      $this->preValidators  = array_merge($this->preValidators, $field->getPreValidators());
      $this->postValidators = array_merge($this->postValidators, $field->getPostValidators());
      
      $this->fields[] = $field;
      
      if (strlen($fieldName) > $this->maxFieldNameLength)
      {
        $this->maxFieldNameLength = strlen($fieldName);
      }
    }
  }
  
  /**
   * Returns this form's class name.
   * 
   * @return  string
   */
  public function getClass()
  {
    return $this->class;
  }
  
  /**
   * Returns this form's name format.
   * 
   * @return  string
   */
  public function getNameFormat()
  {
    return $this->nameFormat;
  }
  
  /**
   * Returns as array of form field data objects.
   * 
   * @return  array
   */
  public function getFields()
  {
    return $this->fields;
  }
  
  /**
   * Returns this form's pre-validators.
   * 
   * @return  array
   */
  public function getPreValidators()
  {
    return $this->preValidators;
  }
  
  /**
   * Returns this form's post-validators.
   * 
   * @return  array
   */
  public function getPostValidators()
  {
    return $this->postValidators;
  }
  
  /**
   * Returns an array of non-null help values.
   * 
   * @return  array
   */
  public function getHelps()
  {
    $helps = array();
    foreach ($this->fields as $field)
    {
      if ($help = $field->getHelp())
      {
        $helps[$field->getName()] = $help;
      }
    }
    
    return $helps;
  }
  
  /**
   * Returns an array of non-null label values.
   * 
   * @return  array
   */
  public function getLabels()
  {
    $labels = array();
    foreach ($this->fields as $field)
    {
      if ($label = $field->getLabel())
      {
        $labels[$field->getName()] = $label;
      }
    }
    
    return $labels;
  }
  
  /**
   * Returns padding for the supplied field name.
   * 
   * @return  string
   */
  public function getPaddingForFieldName($fieldName)
  {
    return str_repeat(' ', $this->maxFieldNameLength - strlen($fieldName));
  }
}

/**
 * YAML form field.
 * 
 * @package     sfFormtasticPlugin
 * @subpackage  generator
 * @author      Kris Wallsmith
 * @version     SVN: $Id$
 */
class sfFormtasticYamlField
{
  protected
    $name             = null,
    $label            = null,
    $help             = null,
    $widgetClass      = 'sfWidgetFormInput',
    $widgetOptions    = array(),
    $widgetAttributes = array(),
    $required         = false,
    $requiredMessage  = null,
    $validators       = array();
  
  /**
   * Constructor.
   * 
   * @param   string  $name
   * @param   array   $params
   */
  public function __construct($name, $params = array())
  {
    $this->initialize($name, $params);
  }
  
  /**
   * Initializes this form field.
   * 
   * @param   string  $name
   * @param   array   $params
   */
  public function initialize($name, $params = array())
  {
    $this->name = $name;
    
    if (isset($params['label']))
    {
      $this->label = $params['label'];
      unset($params['label']);
    }
    
    if (isset($params['help']))
    {
      $this->help = $params['help'];
      unset($params['help']);
    }
    
    if (isset($params['type']))
    {
      $this->widgetClass = $this->translateTypeToWidgetClass($params['type']);
      unset($params['type']);
    }
    elseif ($widgetClass = $this->translateNameToWidgetClass($this->name))
    {
      $this->widgetClass = $widgetClass;
    }
    
    if (isset($params['required']) && $params['required'])
    {
      $this->required = true;
      if (isset($params['required']['msg']))
      {
        $this->requiredMessage = $params['required']['msg'];
      }
    }
    unset($params['required']);
    
    // capture any validator classes
    $baseRc = new ReflectionClass('sfValidatorBase');
    foreach ($params as $validatorClass => $validatorParams)
    {
      if (class_exists($validatorClass))
      {
        $rc = new ReflectionClass($validatorClass);
        if ($rc->isSubClassOf($baseRc))
        {
          $this->validators[] = new sfFormtasticYamlValidator($validatorClass, $validatorParams ? $validatorParams : array());
          unset($params[$validatorClass]);
        }
      }
    }
    
    if (count($params))
    {
      $widget = sfFormtasticYamlGenerator::createInstanceOf($this->widgetClass);
      foreach ($params as $key => $value)
      {
        try
        {
          $widget->setOption($key, $value);
          
          $this->widgetOptions[$key] = $value;
        }
        catch (InvalidArgumentException $e)
        {
          $this->widgetAttributes[$key] = $value;
        }
      }
    }
    
    // some widget classes have sister validators
    if (isset(self::$sisterValidatorMap[$this->widgetClass]) && !$this->hasValidator(self::$sisterValidatorMap[$this->widgetClass]))
    {
      $validatorClass = self::$sisterValidatorMap[$this->widgetClass];
      $validator = sfFormtasticYamlGenerator::createInstanceOf($validatorClass);
      
      $validatorOptions = array();
      foreach ($this->widgetOptions as $key => $value)
      {
        try
        {
          $validator->setOption($key, $value);
          
          $validatorOptions[$key] = $value;
        }
        catch (InvalidArgumentException $e)
        {
        }
      }
      
      $this->validators[] = new sfFormtasticYamlValidator($validatorClass, $validatorOptions);
    }
    
    // if there are no validators, guess based on field name
    if (!$this->validators)
    {
      if ('id' == $this->name)
      {
        $this->validators[] = new sfFormtasticYamlValidator('sfValidatorInteger');
      }
      elseif (false !== stripos($this->name, 'email'))
      {
        $this->validators[] = new sfFormtasticYamlValidator('sfValidatorEmail');
      }
      
      // if all else fails, choose based on whether this field is required
      elseif ($this->isRequired())
      {
        $this->validators[] = new sfFormtasticYamlValidator('sfValidatorString');
      }
      else
      {
        $this->validators[] = new sfFormtasticYamlValidator('sfValidatorPass');
      }
    }
    
    // apply required option and message
    if (count($this->validators) == 1)
    {
      $this->getFirstValidator()->setRequired($this->required, $this->requiredMessage);
    }
    else
    {
      foreach ($this->validators as $validator)
      {
        $validator->setRequired(false);
      }
    }
  }
  
  /**
   * Returns this field's name.
   * 
   * @return  string
   */
  public function getName()
  {
    return $this->name;
  }
  
  /**
   * Returns this field's label.
   * 
   * @return  string
   */
  public function getLabel()
  {
    return $this->label;
  }
  
  /**
   * Returns this field's help message.
   * 
   * @return  string
   */
  public function getHelp()
  {
    return $this->help;
  }
  
  /**
   * Returns this field's widget class.
   * 
   * @return  string
   */
  public function getWidgetClass()
  {
    return $this->widgetClass;
  }
  
  /**
   * Returns this field's widget options.
   * 
   * @return  array
   */
  public function getWidgetOptions()
  {
    return $this->widgetOptions;
  }
  
  /**
   * Returns this field's widget attributes.
   * 
   * @return  array
   */
  public function getWidgetAttributes()
  {
    return $this->widgetAttributes;
  }
  
  /**
   * Returns this field's first validator.
   * 
   * @return  sfFormtasticYamlValidator
   */
  public function getFirstValidator()
  {
    return $this->validators[0];
  }
  
  /**
   * Returns true if this field already has the supplied validator.
   * 
   * @param   mixed $validator
   * 
   * @return  boolean
   */
  public function hasValidator($validator)
  {
    if ($validator instanceof sfFormtasticYamlValidator)
    {
      $validator = $validator->getClass();
    }
    
    foreach ($this->validators as $assignedValidator)
    {
      if ($validator == $assignedValidator->getClass())
      {
        return true;
      }
    }
    
    return false;
  }
  
  /**
   * Returns as array of validator data objects.
   * 
   * @return  array
   */
  public function getValidators()
  {
    return $this->validators;
  }
  
  /**
   * Returns a count of this field's validators.
   * 
   * @return  integer
   */
  public function countValidators()
  {
    return count($this->validators);
  }
  
  /**
   * Returns as array of pre-validators for this field.
   * 
   * @return  array
   */
  public function getPreValidators()
  {
    return array();
  }
  
  /**
   * Returns as array of post-validators for this field.
   * 
   * @return  array
   */
  public function getPostValidators()
  {
    return array();
  }
  
  /**
   * Returns true if this is a required field.
   * 
   * @return  boolean
   */
  public function isRequired()
  {
    return $this->required;
  }
  
  /**
   * Returns this field's required message.
   * 
   * @return  string
   */
  public function getRequiredMessage()
  {
    return $this->isRequired() ? $this->requiredMessage : null;
  }
  
  /**
   * Translate a shorthand type value to a widget class.
   * 
   * @throws  InvalidArgumentException  If widget class could not be found or 
   *                                    does not extend sfWidget
   * 
   * @param   string $type
   * 
   * @return  string
   */
  protected function translateTypeToWidgetClass($type)
  {
    $widgetClass = isset(self::$widgetAliasMap[$type]) ? self::$widgetAliasMap[$type] : $type;
    if (class_exists($widgetClass))
    {
      $rc = new ReflectionClass($widgetClass);
      if (!$rc->isSubclassOf(new ReflectionClass('sfWidget')))
      {
        throw new InvalidArgumentException(sprintf('The class "%s" is not a subclass of sfWidget', $widgetClass));
      }
    }
    else
    {
      throw new InvalidArgumentException(sprintf('The class "%s" could not be found', $widgetClass));
    }
    
    return $widgetClass;
  }
  
  /**
   * Translate a field name to widget class.
   * 
   * @param   string $name
   * 
   * @return  string
   */
  protected function translateNameToWidgetClass($name)
  {
    if ('id' == $name)
    {
      return 'sfWidgetasticFormInputHidden';
    }
    elseif (false !== strpos($name, 'password'))
    {
      return 'sfWidgetasticFormInputPassword';
    }
    elseif ('_at' == substr($name, -3))
    {
      return 'sfWidgetasticFormDateTime';
    }
    elseif ('_on' == substr($name, -3))
    {
      return 'sfWidgetasticFormDate';
    }
  }
  
  static protected
    $widgetAliasMap = array(
      'date'      => 'sfWidgetasticFormDate',
      'datetime'  => 'sfWidgetasticFormDateTime',
      'timestamp' => 'sfWidgetasticFormDateTime',
      'input'     => 'sfWidgetasticFormInput',
      'checkbox'  => 'sfWidgetasticFormInputCheckbox',
      'file'      => 'sfWidgetasticFormInputFile',
      'upload'    => 'sfWidgetasticFormInputFile',
      'hidden'    => 'sfWidgetasticFormInputHidden',
      'password'  => 'sfWidgetasticFormInputPassword',
      'select'    => 'sfWidgetasticFormSelect',
      'dropdown'  => 'sfWidgetasticFormSelect',
      'many'      => 'sfWidgetasticFormSelectMany',
      'radio'     => 'sfWidgetasticFormSelectRadio',
      'textarea'  => 'sfWidgetasticFormTextarea',
      'time'      => 'sfWidgetasticFormTime',
    ),
    $sisterValidatorMap = array(
      'sfWidgetasticFormDate'        => 'sfValidatornatorDate',
      'sfWidgetasticFormDateTime'    => 'sfValidatornatorDateTime',
      'sfWidgetasticFormInputFile'   => 'sfValidatornatorFile',
      'sfWidgetasticFormSelect'      => 'sfValidatornatorChoice',
      'sfWidgetasticFormSelectMany'  => 'sfValidatornatorChoiceMany',
      'sfWidgetasticFormSelectRadio' => 'sfValidatornatorChoice',
      'sfWidgetasticFormTime'        => 'sfValidatornatorTime',
    );
}

/**
 * YAML form validator.
 * 
 * @package     sfFormtasticPlugin
 * @subpackage  generator
 * @author      Kris Wallsmith
 * @version     SVN: $Id$
 */
class sfFormtasticYamlValidator
{
  protected
    $class    = null,
    $options  = array(),
    $messages = array();
  
  /**
   * Constructor.
   * 
   * @param   string  $class
   * @param   array   $params
   */
  public function __construct($class, $params = array())
  {
    $this->initialize($class, $params);
  }
  
  /**
   * Initializes this validator.
   * 
   * @param   string  $class
   * @param   array   $params
   */
  public function initialize($class, $params = array())
  {
    $this->class = $class;
    
    foreach ($params as $key => $value)
    {
      if (in_array($key, array('invalid', 'error')))
      {
        $this->messages['invalid'] = $value;
      }
      elseif (preg_match('/^(\w+)_error$/', $key, $match))
      {
        $this->messages[$match[1]] = $value;
      }
      else
      {
        $this->options[$key] = $value;
      }
    }
  }
  
  /**
   * Sets the validator required option and message.
   * 
   * @param   boolean $required
   * @param   string  $message
   */
  public function setRequired($required, $message = null)
  {
    if ($required)
    {
      unset($this->options['required']);
      if ($message)
      {
        $this->messages['required'] = $message;
      }
    }
    else
    {
      $this->options['required'] = false;
      unset($this->messages['required']);
    }
  }
  
  /**
   * Returns this validator's class.
   * 
   * @return  string
   */
  public function getClass()
  {
    return $this->class;
  }
  
  /**
   * Returns this validator's options.
   * 
   * @return  array
   */
  public function getOptions()
  {
    return $this->options;
  }
  
  /**
   * Returns this validator's messages.
   * 
   * @return  array
   */
  public function getMessages()
  {
    return $this->messages;
  }
}
