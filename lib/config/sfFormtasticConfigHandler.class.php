<?php

/**
 * Config handler for sfFormtasticYaml.
 * 
 * @package     sfFormtasticPlugin
 * @subpackage  config
 * @author      Kris Wallsmith <kris [dot] wallsmith [at] gmail [dot] com>
 * @version     SVN: $Id$
 */
class sfFormtasticConfigHandler extends sfYamlConfigHandler
{
  static protected
    $typeToWidgetMap = array(
      'date'      => 'sfWidgetFormDate',
      'datetime'  => 'sfWidgetFormDateTime',
      'timestamp' => 'sfWidgetFormDateTime',
      'input'     => 'sfWidgetFormInput',
      'checkbox'  => 'sfWidgetFormInputCheckbox',
      'file'      => 'sfWidgetFormInputFile',
      'upload'    => 'sfWidgetFormInputFile',
      'hidden'    => 'sfWidgetFormInputHidden',
      'password'  => 'sfWidgetFormInputPassword',
      'select'    => 'sfWidgetFormSelect',
      'dropdown'  => 'sfWidgetFormSelect',
      'many'      => 'sfWidgetFormSelectMany',
      'radio'     => 'sfWidgetFormSelectRadio',
      'textarea'  => 'sfWidgetFormTextarea',
      'time'      => 'sfWidgetFormTime',
    ),
    $impliedValidatorMap = array(
      'sfWidgetFormDate'        => 'sfValidatorDate',
      'sfWidgetFormDateTime'    => 'sfValidatorDateTime',
      'sfWidgetFormInputFile'   => 'sfValidatorFile',
      'sfWidgetFormSelect'      => 'sfValidatorChoice',
      'sfWidgetFormSelectMany'  => 'sfValidatorChoiceMany',
      'sfWidgetFormSelectRadio' => 'sfValidatorChoice',
      'sfWidgetFormTime'        => 'sfValidatorTime',
    );
  
  protected
    $data   = array(),
    $class  = null,
    $config = array();
  
  /**
   * @see sfConfigHandler
   */
  public function execute($configFiles)
  {
    $this->data[] = '<?php';
    $this->data[] = '';
    $this->data[] = '/*';
    $this->data[] = ' * auto-generated by sfFormtasticConfigHandler';
    $this->data[] = ' * date: '.date('Y/m/d H:i:s');
    $this->data[] = ' */';
    $this->data[] = '';
    
    // parse the yaml
    foreach ($this->getConfiguration($configFiles) as $class => $config)
    {
      $this->class  = $class;
      $this->config = $config;
      
      $extends = 'sfFormtastic';
      if (isset($this->config['extends']))
      {
        if (class_exists($this->config['extends']))
        {
          $rc = new ReflectionClass($this->config['extends']);
          if ($rc->isSubclassOf(new ReflectionClass('sfForm')))
          {
            $extends = $this->config['extends'];
          }
          else
          {
            throw new InvalidArgumentException(sprintf('The class "%s" is not an extension of sfForm', $this->config['extends']));
          }
        }
        else
        {
          throw new InvalidArgumentException(sprintf('The class "%s" could not be found', $this->config['extends']));
        }
      }
      
      $this->data[] = '/**';
      $this->data[] = ' * '.$class.' form.';
      $this->data[] = ' * ';
      $this->data[] = ' * @package    symfony';
      $this->data[] = ' * @subpackage form';
      $this->data[] = ' * @author     Auto-generated from YAML';
      $this->data[] = ' * @version    SVN: $Id$';
      $this->data[] = ' */';
      $this->data[] = 'class '.$class.' extends '.$extends;
      $this->data[] = '{';
      $this->data[] = '  /**';
      $this->data[] = '   * @see sfForm';
      $this->data[] = '   */';
      $this->data[] = '  public function configure()';
      $this->data[] = '  {';
      
      if ('sfFormtastic' != $extends)
      {
        $this->data[] = '    parent::configure();';
        $this->data[] = '';
      }
      
      $this->addWidgets();
      $this->addValidators();
      $this->addLabels();
      $this->addHelps();
      
      if (isset($this->config['name_format']))
      {
        $this->data[] = sprintf('    $this->widgetSchema->setNameFormat(%s);', $this->varExport($this->config['name_format']));
      }
      
      $this->data[] = '  }';
      $this->data[] = '}';
      $this->data[] = '';
    }
    
    return join("\n", $this->data);
  }
  
  /**
   * Add widgets.
   */
  protected function addWidgets()
  {
    $widgets = array();
    if (isset($this->config['fields']))
    {
      foreach ($this->config['fields'] as $name => $config)
      {
        $widget     = 'sfWidgetFormInput';
        $options    = isset($config['options']) ? $config['options'] : array();
        $attributes = isset($config['attributes']) ? $config['attributes'] : array();
        
        if (isset($config['type']))
        {
          $widget = $this->convertTypeToWidgetClass($config['type']);
        }
        else
        {
          // smart-configure based on field name
          switch ($name)
          {
            case 'id':
            $widget = 'sfWidgetFormInputHidden';
            break;
          }
        }
        
        $this->configureImpliedValidator($name, $widget, $options);
        
        $widgets[$name] = array($widget, $options, $attributes);
      }
    }
    
    // build call to ->setWidgets()
    if (count($widgets))
    {
      $this->data[] = '    $this->setWidgets(array(';
      foreach ($widgets as $name => $params)
      {
        $this->data[] = sprintf('      %s => %s,', $this->varExport($name), $this->buildWidget($params));
      }
      $this->data[] = '    ));';
      $this->data[] = '';
    }
  }
  
  /**
   * Convert a user-friendly "type" value to a widget class.
   * 
   * @param   string $type
   * 
   * @return  string A subclass of sfWidget
   */
  protected function convertTypeToWidgetClass($type)
  {
    static $map = null;
    
    if (is_null($map))
    {
      $map = array_merge(self::$typeToWidgetMap, sfConfig::get('app_sf_formtastic_plugin_type_to_widget_map', array()));
    } 
    
    $widgetClass = isset($map[$type]) ? $map[$type] : $type;
    if (class_exists($widgetClass))
    {
      $rc = new ReflectionClass($widgetClass);
      if (!$rc->isSubclassOf(new ReflectionClass('sfWidget')))
      {
        throw new InvalidArgumentException(sprintf('The class "%s" is not a subclass of sfWidget', $widgetClass));
      }
    }
    else
    {
      throw new InvalidArgumentException(sprintf('The class "%s" could not be found', $widgetClass));
    }
    
    return $widgetClass;
  }
  
  /**
   * Add an implied validator to the form configuration.
   * 
   * @param   string  $name
   * @param   string  $widget
   * @param   array   $widgetOptions
   */
  protected function configureImpliedValidator($name, $widget, $widgetOptions = array())
  {
    if (isset(self::$impliedValidatorMap[$widget]))
    {
      $validator = self::$impliedValidatorMap[$widget];
      
      $validatorParams = array();
      if (false !== strpos($validator, 'Choice'))
      {
        if (isset($widgetOptions['choices']))
        {
          $validatorParams['choices'] = $widgetOptions['choices'];
        }
      }
      
      if (isset($this->config['fields'][$name][$validator]))
      {
        $this->config['fields'][$name][$validator] = array_merge($validatorParams, (array) $this->config['fields'][$name][$validator]);
      }
      else
      {
        $this->config['fields'][$name][$validator] = $validatorParams;
      }
    }
  }
  
  /**
   * Build a widget instantiation.
   * 
   * @param   array $params
   * 
   * @return  string
   */
  protected function buildWidget($params = array())
  {
    list($widget, $options, $attributes) = $params;
    
    if (count($attributes))
    {
      return sprintf('new %s(%s, %s)', $widget, $this->varExport($options), $this->varExport($attributes));
    }
    elseif (count($options))
    {
      return sprintf('new %s(%s)', $widget, $this->varExport($options));
    }
    else
    {
      return sprintf('new %s', $widget);
    }
  }
  
  /**
   * Add validators.
   */
  protected function addValidators()
  {
    $formValidators = array();
    foreach ($this->config['fields'] as $name => $config)
    {
      $validators = array();
      
      $required = isset($config['required']);
      $requiredMessage = isset($config['required']['msg']) ? $config['required']['msg'] : null;
      
      // validator configuration
      if (is_array($config))
      {
        foreach ($config as $validator => $params)
        {
          if (class_exists($validator))
          {
            $rc = new ReflectionClass($validator);
            if ($rc->isSubclassOf(new ReflectionClass('sfValidatorBase')))
            {
              $options = array();
              $messages = array();
              
              if (!$required)
              {
                $options['required'] = false;
              }
              
              if (is_array($params))
              {
                foreach ($params as $key => $value)
                {
                  if (in_array($key, array('invalid', 'error')))
                  {
                    $messages['invalid'] = $value;
                  }
                  elseif (preg_match('/^(\w+)_error$/', $key, $match))
                  {
                    $messages[$match[1]] = $value;
                  }
                  else
                  {
                    $options[$key] = $value;
                  }
                }
              }
              
              $validators[$validator] = array($options, $messages);
            }
          }
        }
      }
      
      // smart-configure validator based on field name
      if (!count($validators))
      {
        $options = array();
        if (!$required)
        {
          $options['required'] = false;
        }
        
        if (false !== strpos($name, 'email'))
        {
          $validators['sfValidatorEmail'] = array($options, array());
        }
        elseif ('id' == $name)
        {
          $validators['sfValidatorInteger'] = array($options, array());
        }
        else
        {
          if ($required)
          {
            $validators['sfValidatorString'] = array(array(), array());
          }
          else
          {
            $validators['sfValidatorPass'] = array(array(), array());
          }
        }
      }
      
      $formValidators[$name] = array($validators, $required, $requiredMessage);
    }
    
    // build call to ->setValidators()
    if (count($formValidators))
    {
      $this->data[] = '    $this->setValidators(array(';
      foreach ($formValidators as $name => $formValidator)
      {
        list($validators, $required, $requiredMessage) = $formValidator;
        
        if (count($validators) > 1)
        {
          // use sfValidatorAnd
          $this->data[] = sprintf('      %s => new sfValidatorAnd(array(', $this->varExport($name));
          foreach ($validators as $validator => $params)
          {
            $this->data[] = '        '.$this->buildValidator($validator, $params).',';
          }
          
          $options = array();
          $messages = array();
          
          if (!$required)
          {
            $options['required'] = false;
          }
          elseif ($requiredMessage)
          {
            $messages['required'] = $requiredMessage;
          }
          
          $this->data[] = sprintf('      ), %s, %s),', $this->varExport($options), $this->varExport($messages));
        }
        else
        {
          $validator = key($validators);
          
          $this->data[] = sprintf('      %s => %s,', $this->varExport($name), $this->buildValidator($validator, $validators[$validator], $requiredMessage));
        }
      }
      $this->data[] = '    ));';
      $this->data[] = '';
    }
  }
  
  /**
   * Build a validator instantiation.
   * 
   * @param   string  $validator
   * @param   array   $params
   * @param   string  $requiredMessage
   * 
   * @return  string
   */
  protected function buildValidator($validator, $params, $requiredMessage = null)
  {
    list($options, $messages) = $params;
    
    if ($requiredMessage)
    {
      $messages['required'] = $requiredMessage;
    }
    
    if (count($messages))
    {
      return sprintf('new %s(%s, %s)', $validator, $this->varExport($options), $this->varExport($messages));
    }
    elseif (count($options))
    {
      return sprintf('new %s(%s)', $validator, $this->varExport($options));
    }
    else
    {
      return sprintf('new %s', $validator);
    }
  }
  
  /**
   * Add labels.
   */
  protected function addLabels()
  {
    $labels = array();
    foreach ($this->config['fields'] as $name => $config)
    {
      if (isset($config['label']))
      {
        $labels[$name] = $config['label'];
      }
    }
    
    if (count($labels))
    {
      $this->data[] = '    $this->widgetSchema->setLabels(array(';
      foreach ($labels as $name => $label)
      {
        $this->data[] = sprintf('      %s => %s,', $this->varExport($name), $this->varExport($label));
      }
      $this->data[] = '    ));';
      $this->data[] = '';
    }
  }
  
  /**
   * Add helps.
   */
  protected function addHelps()
  {
    $helps = array();
    foreach ($this->config['fields'] as $name => $config)
    {
      if (isset($config['help']))
      {
        $helps[$name] = $config['help'];
      }
    }
    
    if (count($helps))
    {
      $this->data[] = '    $this->widgetSchema->setHelps(array(';
      foreach ($helps as $name => $help)
      {
        $this->data[] = sprintf('      %s => %s,', $this->varExport($name), $this->varExport($help));
      }
      $this->data[] = '    ));';
      $this->data[] = '';
    }
  }
  
  /**
   * Export and clean up.
   * 
   * @param   mixed $var
   * 
   * @return  string
   */
  protected function varExport($var)
  {
    $export = var_export($var, true);
    
    if (0 === strpos($export, 'array ('))
    {
      $export = preg_replace('/\s+/', ' ', $export);
      $export = str_replace(array(' ( ', ', )'), array('(', ')'), $export);
      if (false === strpos('\' => ', $export))
      {
        $export = preg_replace('/\d+ => /', '', $export);
      }
    }
    
    return $export;
  }
  
  /**
   * @see sfConfigHandler
   */
  static public function getConfiguration(array $configFiles)
  {
    return self::parseYamls($configFiles);
  }
}
